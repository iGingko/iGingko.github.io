
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>iGingko</title>
	<meta name="author" content="Connor">

	
	<meta name="description" content="Comments Block详解 Block 是什么 闭包是一个函数指针，再加上该函数执行的外部的上下文变量，而Block实际上就是Objective-C语言对闭包的实现
Block是封装了代码逻辑(代码块)的OC对象
一个Block就是一个匿名的内联代码集合体
在某种意义上, &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="iGingko" type="application/atom+xml">
	
	<link rel="canonical" href="http://iGingko.me/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	
</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		document.write("<img src='/images/Logo.jpg' alt='Profile Picture' style='width: 160px;' />");
	</script>
</div>
<h1><a href="/">iGingko</a></h1>
<p class="subtitle">Talk is cheap, Show me the code!.</p>
<nav id="main-nav"><ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About Me</a></li>
</ul>

</nav>
<nav id="sub-nav">
	<div class="social">
		
		<a class="weibo" href="http://www.weibo.com/1307895851" title="Weibo">Weibo</a>
		
		
		
		<a class="google" href="https://plus.google.com/106727423024678549919" rel="author" title="Google+">Google+</a>
		
		
		<a class="twitter" href="http://twitter.com/iGingko" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/iGingko" title="GitHub">GitHub</a>
		
		
		<a class="dribbble" href="http://www.dribbble.com/iGingko" title="Dribbble">Dribbble</a>
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
<hgroup>
  <p class="subtitle"> You know ultimately it comes down to taste, it comes down to trying to expose yourself to the best things that humans have done, and try to bring these things into what you are doing.							
    -- Steve Job </p>
</hgroup>

</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-12-16T15:10:58+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blog/2014/12/16/my-block/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/12/16/my-block/" itemprop="url">Block详解</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>Block 是什么</h2>

<blockquote><ul>
<li>闭包是一个函数指针，再加上该函数执行的外部的上下文变量，而Block实际上就是Objective-C语言对闭包的实现</li>
<li>Block是封装了代码逻辑(代码块)的OC对象</li>
<li>一个Block就是一个匿名的内联代码集合体</li>
<li>在某种意义上,也可以把Block理解成为OC的匿名函数</li>
<li>块是以扩展的形式加入到GCC编译器的，在近期版本的CLang中也可以使用</li>
</ul>
</blockquote>

<p>总而言之，<strong>Block是实现闭包功能并封装了代码逻辑的OC对象</strong></p>

<h2>怎样使用Block</h2>

<h3>声明</h3>

<p><img src="/images/posts/blocks.png" alt="Block Structure" /></p>

<p>基本语法如下</p>

<pre><code>returnvalue (^BlockName)(parameters)
</code></pre>

<p>每个块都具备“固有类型”，所以也可以通过<strong>typedef</strong>来定义类型</p>

<pre><code>typedef int (^EOCScomeBlock)(BOOL flag,int value)
</code></pre>

<h3>实现</h3>

<pre><code>int (^AddBlock)(int,int) = ^(int a, int b){
    return a + b;
}
</code></pre>

<h2>Block的内部结构</h2>

<p><img src="/images/posts/block-struct.jpg" alt="Block Structure" /></p>

<p>如图所示，BLock一共分为6个部分:</p>

<ol>
<li>块本身是对象，在存放块对象的内存区域中，首个变量是指向Class对象的指针，该指针叫做isa</li>
<li>flags,用于按Bit位表示一些block的附加信息，</li>
<li>reverted 保留变量</li>
<li>invoke，这是内存布局中最重要的变量，这是个函数指针，指向块的实现代码(函数调用地址)。函数原型至少要接受一个void*型的参数，此参数代表块</li>
<li>descriptor标示该Block的附加描述信息，主要是Size大小，以及copy和dispose辅助函数的指针。辅助函数在Copy以及dispose的时候要指向一些其它操作，比如说，前者要保留捕获的对象，而后者则将之释放</li>
<li>variables, capture过来的变量，block能够访问它外部的局部变量，就是因为将这些变量复制到了结构体中。但需要注意的时拷贝的病不是对象本身，而是指向这些对象的指针变量。</li>
</ol>


<h2>全局快、栈块和堆块</h2>

<p>在MRC下，定义块的时候所占的内存都是分配在栈中的,也就是说，块只在定义它的那个范围内有效。如下代码就有危险:</p>

<pre><code>void (^block)();
if (){
    block = ^{};
}else {
    block = ^{};
}
block();
</code></pre>

<p>在上面的代码中，if 和else中的代码都是分配在栈中的，等离开了相应的范围之后，编译器就有可能把分配给Block的内存覆盖掉，于是这两个Block只能保证在对应的范围内有效。</p>

<p>为了解决上面的问题，可以给块对象发送<strong>Copy</strong>消息，这样的话就会把块对象从栈中拷贝到堆中，块就成了带引用计数的对象了。修改之后的代码如下:</p>

<pre><code>void (^block)();
if (){
    block =[^{} copy];
}else {
    block = [^{} copy];
}
block();
</code></pre>

<p>上面说的时栈块和堆块，除此之外还有一种块叫做全局块，这种块不会捕捉任何状态(比如外围的变量等)，运行时也无须有状态来参与。块使用整个内存区域，在编译器已经完全确定了，因此，全局块可以声明在全局内存汇总，而不需要每次用到的时候在栈中创建。另外，对全局块的拷贝操作是个空操作，因为全局块不能被系统所回收。这种块实际上相当于单例。</p>

<p><strong>在ARC下，无论哪种块都是被分配在堆中的</strong></p>

<h2>Block的闭包性</h2>

<p>在block内部，可以像普通函数一样访问数据：局部变量、传递给block的参数，全局变量/函数。并且由于block具有<strong>闭包性</strong>，所以还能访问非局部变量(non-local variable)。非局部变量定义在block之外，但是在block内部有它的作用域。例如，getFullCarName可以使用定义在block前面的make变量</p>

<pre><code>NSString *make = @"Honda";
NSString *(^getFullCarName)(NSString *) = ^(NSString *model) {
    return [make stringByAppendingFormat:@" %@", model];
};
NSLog(@"%@", getFullCarName(@"Accord"));    // Honda Accord
</code></pre>

<p>非局部变量会以const变量被拷贝并存储到block中，也就是说block对其是只读的。如果尝试在block内部给make变量赋值，会抛出编译器错误。</p>

<p><img src="/images/posts/const-non-local-variables.png" alt="Block Structure" /></p>

<p>以const拷贝的方式访问非局部变量，意味着block实际上并不是真正的访问了非局部变量——只不过在block中创建了非局部变量的一个快照。当定义block时，无论非局部变量的值是什么，都将被冻结，并且block会一直使用这个值，即使在之后的代码中修改了非局部变量的值。下面通过代码来看看，在创建好block之后，修改make变量的值，会发生什么</p>

<pre><code>NSString *make = @"Honda";
NSString *(^getFullCarName)(NSString *) = ^(NSString *model) {
    return [make stringByAppendingFormat:@" %@", model];
};
NSLog(@"%@", getFullCarName(@"Accord"));    // Honda Accord

// Try changing the non-local variable (it won't change the block)
make = @"Porsche";
NSLog(@"%@", getFullCarName(@"911 Turbo")); // Honda 911 Turbo
</code></pre>

<p>block的闭包性为block与上下文交互的时候带来极大的便利性，当block需要额外的数据时，可以避免使用参数——只需要简单的使用非局部变量即可。</p>

<h2>修改局部变量</h2>

<p>冻结中的非局部变量是一个常量值，这也是一种默认的安全行为——因为这可以防止在block中的代码对非局部变量做了意外的修改。那么如果我们希望在block中对非局部变量值进行修改要如何做呢——用__block存储修饰符(storage modifier)来声明非局部变量：</p>

<pre><code>__block NSString *make = @"Honda";
</code></pre>

<p>这将告诉block对非局部变量做引用处理，在block外部make变量和内部的make变量创建一个直接的链接(direct link)。现在就可以在block外部修改make，然后反应到block内部，反过来，也是一样。</p>

<p><img src="/images/posts/mutable-non-local-variables.png" alt="Block Structure" /></p>

<h2>Block作用</h2>

<ul>
<li>作为回调，取代Delegate,可以让代码变得简洁紧凑，以及减少函数声明的数量</li>
<li>block能够在函数内部声明实现，并捕捉词法范围内的状态，并能在一定条件下修改这些状态</li>
<li>用Blcok作为回调，可以让代码逻辑变得紧凑，并切可以直接访问局部变量</li>
<li>BLock可以使用在任务完成回调处理、消息监听回调处理、错误回调处理、枚举回调、视图动画变化、排序</li>
<li>和GCD结合使用，实现多线程</li>
</ul>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-11-21T11:16:22+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blog/2014/11/21/my-git/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/11/21/my-git/" itemprop="url">Git学习笔记</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<blockquote><p>用了Git才知道什么才是真正的版本管理，跟之前的SVN相比，要甩开它几条街，现将最近学习的一些心得分享给大家。</p></blockquote>

<h3>学习资源整理</h3>

<ol>
<li>  <a href="http://git-scm.com/book/zh">Pro Git的中文站点</a></li>
<li> <a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000?from=singlemessage&amp;isappinstalled=0">廖雪峰的Git教程</a></li>
<li> <a href="http://rogerdudler.github.io/git-guide/index.zh.html">GIt简明指南</a></li>
</ol>


<h3>Git简介</h3>

<ol>
<li> Git是世界上最先进的分布式版本控制系统(没有之一)</li>
<li> Git是Linux的创始人Linus于2005年花两周时间用C写的一个分布式版本管理系统</li>
<li> Linus自己写Git的缘由是BitMover发现有些Linux社区的牛人试图破解BitKeeper的协议，于是收回了Linux社区的免费使用权</li>
<li> 2008年Github上线，更是让Git成为最流行的分布式版本控制系统</li>
</ol>


<h3>集中式VS分布式</h3>

<ol>
<li> 集中式版本管理系统（eg:SVN、CVS）版本库是集中放在中央服务器的，必须联网才能工作</li>
<li> 分布式版本管理系统，没有中央服务器的概念，每个电脑上都是一个完整的版本库</li>
<li> 分布式要比集中式安全很多，因为每个人的电脑上都有一个完整的版本库。一般也会有一个服务器，但仅仅是为了方便大家来交换修改</li>
<li> 分布式强大的分支功能，要拉集中式几条街</li>
</ol>


<h3>GIt基本操作</h3>

<ol>
<li> 创建版本库  git init</li>
<li> 查看状态  git  status</li>
<li> 添加到暂存区  git add filename    添加所有修改 git add -A 或者 git add .</li>
<li> 提交文件到仓库  git commit  -m  ‘ Commit’  或者  git commit -a -m ‘ ‘(这样就可以省略git add步骤)</li>
<li> 查看对文件做了哪些修改  git diff FileName</li>
<li> 查看历史记录  git  log   可以加参数  git log —pretty=oneline</li>
<li> 版本回退  HEAD表示当前版本，也就是最新的提交  上一个版本是HEAD^,上上个版本是HEAD^^,往上100个版本是HEAD~100</li>
<li> 版本回退到上几个版本   git reset - - hard HEAD^  也可以根据版本号 进行回退 git reset —3628164</li>
<li> 如果退回之前的版本又后悔了，想退回原来最新的版本怎么办，可以通过git  relog 找到之前最新的版本号</li>
<li>. 撤销修改  git checkout - - fileName   如果已经add到暂存区，那么需要 git reset HEAD fileName</li>
<li>. 删除文件  rm fileName 删除工作区文件  git rm filename git commit  如果只是从工作区删除 那么可以用 git checkout - - filename</li>
<li>. 把本地GIt仓库推送到服务器上 git remote add origin git@github.com:xxx/xxx.git  git push -u origin master  “-u”参数不但会把本地的master分支内容推送到远程新的master分支，还会把本地的masterfe分支和远程的master分支关联起来</li>
<li>. git push origin branch Name 推送分支</li>
</ol>


<h3>Git 分支</h3>

<ol>
<li> 查看本地分支  git branch -l</li>
<li> 查看服务器分支  git branch -r</li>
<li> git  checkout -b branchName 相当于git branch branchName  和 git checkout branchName 新建一个分支 然后checkout</li>
<li> git  checkout -b branchName origin/branchName  是把服务器上的相应分支拉到本地œ</li>
<li> 合并分支  git merge brName 把brName分支合并到当前分支</li>
<li> 删除分支  git  branch -d brNa  如果删除不了就把小d改成大D</li>
<li> 查看分支的合并情况  git  log  - - graph - -pretty=oneline  - - abbrev-commit</li>
<li> 通常，合并分支时，如果可能，Git会用“Fase Forward”模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用“Fase forward”模式，git就会在merge时生成一个新的commit,这样，从分支历史上就可以看出分支信息  git  merge   - - no-ff -m ‘ merge with mo-ff’</li>
<li> 分支策略  首先master分支是非常稳定的，也就是仅仅用来发布新版本，平时不能在上面干货。要在dev分支上干货 每个人都有自己的分支，只要时不时的往dev分支上合并就行了</li>
<li><p>. <img src="/images/posts/br.png" alt="Alt text" /></p></li>
<li><p>. Bug分支  当临时要去修改其它分支Bug,而当前所在分支还没有提交也不想提交时，有以下方法：1、比较高大上的 先执行git  stash 把当前分支的修改临时存储起来，修复完Bug之后再回来  git stash lish 产看stash目录  可以用git stash pop 直接恢复，而且会删除stash命令 。如果用git stash apply 就必须自行执行 git stash drop .  多次stash的话 可以用 git stash apple stash@{0}</p></li>
<li>. 开发一个feature最好是新建一个分支，如果要丢弃一个没有被合并过的分支，可以通过git branch -D name强行删除</li>
<li>. git push origin —delete 删除远程分支</li>
</ol>


<h3>解决冲突</h3>

<p> 如果git push的时候和服务器发生冲突，那么</p>

<ol>
<li> git pull 把remote上的代码拉下来</li>
<li> 手动解决冲突</li>
<li> git add .</li>
<li> git rebase - -continue</li>
<li> git push origin branchName</li>
</ol>


<h3>Git版本库</h3>

<p><img src="/images/posts/GitVerLib.jpeg" alt="Alt text" /></p>

<h3>Git的优势</h3>

<ol>
<li> Git不需联网就能工作</li>
<li> Git比较安全，每个电脑上都是一个完整的版本库</li>
<li> Git有强大的分支功能</li>
<li> Git跟踪的时修改，问不是文件。比如对一个文件修改了两次，那么就会跟踪两次</li>
</ol>


<h3>Git工具</h3>

<ol>
<li>Tower  强力推荐</li>
<li>Github官方工具</li>
<li>SourceTree</li>
</ol>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-09-01T11:44:19+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blog/2014/09/01/the-relation-between-uiview-and-calayer/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/09/01/the-relation-between-uiview-and-calayer/" itemprop="url">Animation&#8211;UIView和CALayer的关系</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h3>继承关系</h3>

<ol>
<li><p>UIView的继承结构为: <strong>UIResponder : NSObject</strong>。
官方的解释为:</p>

<blockquote><p>The <strong>UIResponder</strong> class defines an interface for objects that respond to and handle events. It is the superclass of UIApplication, UIView and its subclasses (which include UIWindow). Instances of these classes are sometimes referred to as responder objects or, simply, responders.</p>

<p>The <strong>UIView</strong> class defines a rectangular area on the screen and the interfaces for managing the content in that area. At runtime, a view object handles the rendering of any content in its area and also handles any interactions with that content. The UIView class itself provides basic behavior for filling its rectangular area with a background color. More sophisticated content can be presented by subclassing UIView and implementing the necessary drawing and event-handling code yourself. The UIKit framework also includes a set of standard subclasses that range from simple buttons to complex tables and can be used as-is. For example, a UILabel object draws a text string and a UIImageView object draws an image.</p></blockquote>

<p>  由官方的解释可以看出，UIResponder是用来相应事件的，相应的UIView可以响应用户事件。</p></li>
<li><p>CALayer的继承结构为：CALayer的继承结构为：<strong>CALayer: NSObject</strong>。
CALayer是直接继承NSObject的，因为缺少了UIResponder类，所以CALayer是不能响应用户事件的。</p>

<blockquote><p>The CALayer class is the model class for layer-tree objects. It encapsulates the position, size, and transform of a layer, which defines its coordinate system. It also encapsulates the duration and pacing of a layer and its animations by adopting the CAMediaTiming protocol, which defines a layer’s time space.</p></blockquote>

<p>  从官方的解释中可以看出，CALayer定义了position、size、transform、animations 等基本属性.</p></li>
</ol>


<p>从上面的分析中，我们可以得出UIView主要负责事件的响应处理，CALayer主要负责绘制。那么UiView中的size、Frame、Position又是怎么来的呢？</p>

<h3>所属框架</h3>

<ol>
<li><p><strong>UIView</strong>是在 /System/Library/Frameworks/UIKit.framework中定义的。</p>

<blockquote><p>The UIKit framework provides the classes needed to construct and manage an application’s user interface for iOS. It provides an application object, event handling, drawing model, windows, views, and controls specifically designed for a touch screen interface.</p></blockquote>

<p>  可见UIKit主要是用来构建用户界面，并且是可以响应事件的（得意于UIView的父类UIResponder）。那么UIView是通过什么来绘制图片和文字信息的呢？而iOS中2D图像绘制是通过QuartzCore.framework实现的。难道是通过QuartzCore.framework实现的？那又是通过什么方式和QuartzCore.framework联系起来的呢？</p></li>
<li><p><strong>CALayer</strong>是在/System/Library/Frameworks/QuartzCore.framework定义的。而且CALayer作为一个低级的，可以承载绘制内容的底层对象出现在该框架中。</p>

<p> UIView相比CALayer最大区别是UIView可以响应用户事件，而CALayer不可以。UIView侧重于对显示内容的管理，CALayer侧重于对内容的绘制。</p>

<blockquote><p>Core Animation doesn&rsquo;t provide a means for actually displaying layers in a window, they must be hosted by a view. When paired with a view, the view must provide event-handling for the underlying layers, while the layers provide display of the content.
The view system in iOS is built directly on top of Core Animation layers. Every instance of UIView automatically creates an instance of a CALayer class and sets it as the value of the view’s layer property. You can add sublayers to the view’s layer as needed.</p></blockquote></li>
</ol>


<p><strong>由此可见UIView是基于CALayer的高层封装。The view system in iOS is build directly on top of Core Animation layers</strong></p>

<h3>Summary</h3>

<ul>
<li>UIView是iOS系统中界面元素的基础，通过CALyaer来绘制内容并显示，并且可以处理用户事件。而CALayer只关心绘制，对内同进行动画处理，不能处理用户事件。</li>
<li>UIView和CALayer是相互依赖的关系。UIView依赖与calayer提供的内容，CALayer依赖uivew提供的容器来显示绘制的内容。归根到底CALayer是这一切的基础，如果没有CALayer，UIView自身也不会存在，UIView是一个特殊的CALayer实现，添加了响应事件的能力。</li>
<li>UIView的Layer树形在系统内部，被系统维护着三份Copy。
  第一份，<strong>模型树(Model Layer Tree)</strong>  就是代码可以操纵的，例如更改Layer的属性等等就在这一份
  第二份，<strong>呈现树(Presentation layer Tree)</strong>  这是一个中间层，呈现树的属性和动画运行过程中界面看到的是一致的，也可以说这层是Layer在屏幕中的真实位置。
  第三份，<strong>渲染树(Rendering Layer Tree)</strong>  渲染树是私有的，开发者无法访问到。渲染树是对呈现树的数据进行渲染,为了不阻塞主线程,渲染的过程是在单独的进程或线程中进行的,所以你会发现Animation的动画并不会阻塞主线程.
  这三棵树的逻辑结构是一样的，区别只有各自的属性。</li>
<li>CoreAnimation负责维护两个平行layer层次结构：model layer tree(模型层树)和presentation layer tree (表示层树)。前者反映我们直接能看到的layers的状态，而后者的layers则是动画正在表现的近似值</li>
</ul>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-08-26T16:46:15+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blog/2014/08/26/objective-c-message-mechanism/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/08/26/objective-c-message-mechanism/" itemprop="url">Objective-c的消息机制</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h3>前言</h3>

<p>Ojbective-C的语法设计主要基于Smalltalk，除了提供传统的面向对象编程特性之外，还增加了很多类似动态语言Ruby、Python才具有的特性，例如动态类型、动态加载、动态绑定等等，同时强化了消息传递机制和表意（Intention Revealing Interface）接口的概念。</p>

<h3>理解Objective-C 运行时消息机制的几个比较重要的概念</h3>

<ul>
<li><code>isa指针</code>:isa指针指向这个对象所属的Class.</li>
<li><code>methodLists</code>: 是一个指向实例方法列表的指针</li>
<li><code>cache</code> :缓存了常用的实例方</li>
<li><code>Method</code> <strong>定义</strong>对象方法和类方法。这个类型提供了方法的名字(就是<strong>选择器</strong>)、参数数量和类型，以及返回值（这些信息合起来成为方法的签名），还有一个指向代码的指针(IMP 也就是方法的实现)</li>
<li><code>SEL</code> 定义选择器。选择器是方法名的唯一标示符。</li>
<li><code>IMP</code> 定义方法的实现。这只是一个指向某个函数的指针，该函数接受一个对象、一个选择器和一个可变长参数列表，返回一个对象：<code>typedef id (*IMP)(id,SEL,...)</code></li>
</ul>


<h3>C语言中的“静态绑定”与简单“动态绑定“实现</h3>

<p>由于OC是C的超集，所以最好是先理解C语言的调用方式。C语言使用<em>静态绑定</em>，也就是说，在编译期就能决定运行时所应调用的函数。以下列代码为例：
    #import &lt;stdio.h></p>

<pre><code>void printHello() {
    printf("Hello,World!");
}

void printGoodbye(){
    printf("Goodbye,World!");
}

void doTheThing(int type){
    if(type == 0){
        printHello();
    }else {
        printGoodbye();
    }
    return 0;
}
</code></pre>

<p>上面代码中，如果不考虑&#8221;内联&#8221;，那么编译器在编译代码的时候就已经知道程序中有printHello和printGoodbye这两个函数了，于是会直接生成调用这些函数的指令。而函数地址实际上是<strong>硬编码</strong>在指令之中的。再看看下面的代码呢？
    #import &lt;stdio.h></p>

<pre><code>void printHello() {
    printf("Hello,World!");
}

void printGoodbye(){
    printf("Goodbye,World!");
}

void doTheThing(int type){
    void (*fnc)();
    if(type == 0){
        fnc = printHello;
    }else {
        fnc = printGoodbye;
    }

    fnc();
    return 0;
}
</code></pre>

<p>这时使用的就是<strong>动态绑定</strong>了，因为所要调用的函数直到运行期才能确定。当然真正的Runtime要复杂得多，而上面只是一个简单的实现说明而已。</p>

<blockquote><p>在Objective-C中，如果向某个对象传递消息，那就会使用<strong>动态绑定</strong>机制来决定需要调用的方法。在底层，所有方法都是普通的C语言函数，然而对象受到消息后，究竟调用哪个方法完全由运行期决定，甚至可以在运行时改变，这使得Obhective-C成为一门真正动态的语言。</p></blockquote>

<h3>动态绑定的全过程</h3>

<p>给对象发送消息可以这样来写：</p>

<pre><code>id = [someObject messageName:parameter];//[reciever message];
</code></pre>

<p>在上面的例子中，someObject叫做reciever,messageName叫做selector，selector和参数合起来成为message.</p>

<p>动态绑定过程如下：
1. 编译器看到消息，转换为objc_msgSend这个标准的C语言函数。其原型为：</p>

<pre><code>    void objc_msgSend(id self,SEL cmd,...)
</code></pre>

<p>这个是参数可变的函数，能接受两个或两个以上的参数。第一个参数代表接收者，第二个参数代表选择子(SEL是选择子的类型)，后续参数就是消息中的参数，其顺序不变。selector指的就是方法的名称
2. objc_msgSend 会依据<code>SEL</code>在接收者所属的类中搜索<code>methodlists</code>
3. 如果找到相应的<code>Method</code>,那么就会根据<code>IMP</code>,跳转至方法实现。如果找不到，那就沿着继承体系向上查找，找到合适的再跳转。
4. 如果最终找不到，就会执行<code>消息转发</code></p>

<h5>在整个过程中有三点需要另外注意：</h5>

<ul>
<li>每个类中都有一个方法缓存列表(<code>cache</code>),在调用完成一个方法后，会将匹配结果进行缓存，下次执行就会很快了。</li>
<li><p>Objective-C的方法可视为简单的C函数，其原型如下：</p>

<pre><code>  &lt;return_type&gt; class_selector(id self,SEL _cmd,...)
</code></pre>

你会发现，原型的样子和objc_msgSend函数很像，这不是巧合，而是为了利用<strong><code>尾调优化技术</code></strong>

<blockquote><p>如果函数的最后一项操作是条用另外一个函数，那么就可以利<code>尾调优化</code>技术。编译器会生成跳转至另一个函数所需的指令，而且不会向调用堆栈中推入新的<code>栈帧(frame stack)</code>。只有当某函数的最后一项操作仅仅是调用其他函数而不会将其返回值另作他用的时候，才能执行<code>尾调优化</code>。如果不这么做的话，每次调用方法，都需要为调用objc_msgSend函数准备<code>栈帧</code>，大家都可以看到在<code>栈追踪(stack trace)</code>中看到这种栈帧，而且还会过早的<code>栈溢出(stack overflow)</code></p></blockquote></li>
<li>当待发的消息返回结构体，那么交由<code>obje_msgSend_stret</code>处理。发的消息返回浮点数，交由<code>objc_msgSend_fpret</code>处理。如果发消息给超类 [super message:para],那么交由<code>objc_msgSendSuper</code>处理。</li>
</ul>


<h3>消息转发</h3>

<p>当对象接收到无法解读的消息后，就会启动<code>消息转发(message forwarding)</code>,开发者在编写自己的类时，可于转发过程中设置挂钩，用以执行特定的逻辑，而不使程序崩溃或者做其他处理。</p>

<p>消息转发可分为两大阶段:
1. 第一阶段为动态方法解析。先征询接收者，所属的类，看其是否能动态添加方法，以处理当前这个“未知的选择子”(unknown selector),这叫做“动态方法解析”(dynamic method resolution)
2. 第二阶段涉及“完整的消息转发机制”(full forwarding mechanism)。如 果运行期系统已经把第一阶段执行完了,那么接收者自己就无法再以动态新增方法的手段来 响应包含该选择子的消息了。此时,运行期系统会请求接收者以其他手段来处理与消息相关 的方法调用。这又细分为两小步。首先,请接收者看看有没有其他对象能处理这条消息。若 有,则运行期系统会把消息转给那个对象,于是消息转发过程结束,一切如常。若没有“备 援的接收者”(replacement receiver),则启动完整的消息转发机制,运行期系统会把与消息有 关的全部细节都封装到 NSInvocation 对象中,再给接收者最后一次机会,令其设法解决当前 还未处理的这条消息。</p>

<h4>动态方法解析</h4>

<p>对象在收到无法解读的消息后,首先将调用其所属类的下列类方法:</p>

<pre><code>+ (BOOL)resolveInstanceMethod:(SEL)selector
</code></pre>

<p>如果尚未实现的方法为类方法，那么就会调用另外一个方法:
    + (BOOL)resolveClassMethod:(SEL)selector</p>

<p>使用这种办法的前提是:相关方法的实现代码已经写好,只等着运行的时候动态插在类 里面就可以了。此方案常用来实现 @dynamic 属性,比如说,要访问 CoreData 框架中 NSManagedObjects 对象的属性时就可以这么做,因为实现这些属性所需的存取方法 在编译期就能确定。
下列代码演示了如何用“resolveInstanceMethod:”来实现 @dynamic 属性: id autoDictionaryGetter(id self, SEL <em>cmd);
void autoDictionarySetter(id self, SEL </em>cmd, id value);
    + (BOOL)resolveInstanceMethod:(SEL)selector {
    NSString <em>selectorString = NSStringFromSelector(selector); if ( /</em> selector is from a @dynamic property */ ) {
    if ([selectorString hasPrefix:@&ldquo;set&rdquo;]) { class_addMethod(self,selector, (IMP)autoDictionarySetter, &ldquo;v@:@&rdquo;);
    } else {
        class_addMethod(self,selector, (IMP)autoDictionaryGetter, &ldquo;@@:&rdquo;);
    }
        return YES;
    }
        return [super resolveInstanceMethod:selector];
    }
首先将选择子化为字符串,然后检测其是否表示设置方法。若前缀为 set,则表示设置 方法,否则就是获取方法。不管哪种情况,都会把处理该选择子的方法加到类里面,所添加 的方法是用纯 C 函数实现的。C 函数可能会用代码来操作相关的数据结构,类之中的属性数 据就存放在那些数据结构里面。以 CoreData 为例,这些存取方法也许要和后端数据库通信, 以便获取或更新相应的值。</p>

<h4>备援接收者</h4>

<p>当前接收者还有第二次机会能处理未知的选择子,在这一步中,运行期系统会问它:能 不能把这条消息转给其他接收者来处理。与该步骤对应的处理方法如下:</p>

<pre><code>- (id)forwardingTargetForSelector:(SEL)selector
</code></pre>

<p>方法参数代表未知的选择子,若当前接收者能找到备援对象,则将其返回,若找不到, 就返回 nil。通过此方案,我们可以用“组合”(composition)来模拟出“多重继承”(multiple inheritance)的某些特性。在一个对象内部,可能还有一系列其他对象,该对象可经由此方法 将能够处理某选择子的相关内部对象返回,这样的话,在外界看来,好像是该对象亲自处理 了这些消息似的。
请注意,我们无法操作经由这一步所转发的消息。若是想在发送给备援接收者之前先修 改消息内容,那就得通过完整的消息转发机制来做了</p>

<h4>完整的消息转发</h4>

<p>如果转发算法已经来到这一步的话,那么唯一能做的就是启用完整的消息转发机制 了。首先创建 NSInvocation 对象,把与尚未处理的那条消息有关的全部细节都封于其中。 此对象包含选择子、目标(target)及参数。在触发 NSInvocation 对象时,“消息派发系统”(message-dispatch system)将亲自出马,把消息指派给目标对象。 此步骤会调用下列方法来转发消息:
    - (void)forwardInvocation:(NSInvocation*)invocation
这个方法可以实现得很简单:只需改变调用目标,使消息在新目标上得以调用即可。然 而这样实现出来的方法与“备援接收者”方案所实现的方法等效,所以很少有人采用这么简 单的实现方式。比较有用的实现方式为:在触发消息前,先以某种方式改变消息内容,比如 追加另外一个参数,或是改换选择子,等等。
实现此方法时,若发现某调用操作不应由本类处理,则需调用超类的同名方法。这样的话,继承体系中的每个类都有机会处理此调用请求,直至 NSObject。如果最后调用了 NSObject 类的方法,那么该方法还会继而调用“doesNotRecognizeSelector:”以抛出异常, 此异常表明选择子最终未能得到处理。</p>

<h4>消息转发全流程</h4>

<p>这张流程图描述了消息转发机制处理消息的各个步骤。
<img src="/images/posts/MessageTrans.png" alt="消息转发全程" />
接收者在每一步中均有机会处理消息。步骤越往后,处理消息的代价就越大。最好能在 第一步就处理完,这样的话,运行期系统就可以将此方法缓存起来了。如果这个类的实例稍 后还收到同名选择子,那么根本无须启动消息转发流程。若想在第三步里把消息转给备援的 接收者,那还不如把转发操作提前到第二步。因为第三步只是修改了调用目标,这项改动放 在第二步执行会更为简单,不然的话,还得创建并处理完整的 NSInvocation。</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-08-24T15:40:45+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blog/2014/08/24/the-object-model/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/08/24/the-object-model/" itemprop="url">Objective-C 对象模型</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>前言</h2>

<p>通过对Runtime的<a href="http://www.opensource.apple.com/tarballs/objc4/">开源代码</a>的分析，得出Objective-C的对象模型的实现细节，以及Objective-C语言对象中对<code>isa swizzling</code>和<code>method swizzling</code>的支持。</p>

<h2>概述</h2>

<blockquote><ul>
<li>Objective-C是一门面向对象，并且在C的基础上加入了Smalltalk式的消息机制而形成的编程语言，是C的超级，它主要被苹果公司用于开发Mac OS X和iOS操作系统。</li>
<li>Objective-C是C的扩展，设计思路上借鉴了Smalltalk的面向对象和消息机制的思想。从我个人使用过的面向对象语言来看Objc是对消息传递支持的最彻底也最显式的。其它的C++、Java、Python、Ruby都体现的不明显，更倾向于对象的封装和抽象.</li>
<li>Objc和C++基本上是两门语言，没有太大的关系。Objc本身是静态语言，编译后就是机器码，执行效率很高，但引入了很多类似Python、Ruby的动态特性，像动态类型推断，id，selector，block等特性，所以又非常灵活。
-用惯了Java或C++会觉得Objc的语法很怪，但是放空自己去学习这门语言的话，你会很快爱上它的消息式的编程风格，加上强悍的XCode，无论是写mac应用还是ios应用，都会非常得心应手。</li>
</ul>
</blockquote>

<h2>苹果为什么会选择Objective-C</h2>

<p>关于苹果为什么采用Ojbc的问题，说明一下，其实不是苹果采用了Objc，而是乔布斯创建的Next公司的操作系统NextStep采用了Ojbc作为原生语言。NextStep是以Mach和BSD为基础，Objc是其语言和运行库，后来的事大家都清楚，苹果买了NextStep，乔帮主回归，NextStep也成了Max OS X的基础。以后发展越来越好，Objc反而成了Apple的当家语言，现在基本上是Apple在维护Objc的发展。</p>

<h2>通过源代码分析OC对象模型</h2>

<h3>Objective-C类和对象的声明</h3>

<pre><code>//objc.h
typedef struct objc_class *Class;//代表类 Objective-C class
typedef struct objc_object *id;//代表对象，也就是类的实例 instance of a class.

//NSObject.h -- NSProxy.h
@interface NSObject &lt;NSObject&gt; {
    Class isa  OBJC_ISA_AVAILABILITY;
}
</code></pre>

<blockquote><ul>
<li>对象中的数据组成形式为isa varFromGrandFather varFromFather VarFromSon</li>
<li>从内存形式上看，对象内的成员变量，是从祖类继承而来，在对象内部生成副本</li>
<li>从对象的内存组织上来看，对象本身不关心行为(对象的方法或实例方法)，重点都在数据组织上</li>
<li>isa是一个指针,指向了该对象的类.实质上,同一个类的实例,都指向同一个类对象(类也是一种特殊对象).类中包含了实例方法,也就是说,同一个类的所有实例共用了这些实例方法.消息就是发送给对象,对象转交给其isa指向类去处理</li>
<li>Objective-C的这种设计,既可以友好地实现面向对象,又可以有效地节约内存.降低冗余数据.对象对方法的调用是通过isa间接去调用,这样就造成了方法调用的动态性</li>
<li>一个对象并不晓得它能否应答一个方法,它本身既不包含方法的实现,也不包含有方法的指针,而是间接通过isa转到自己的类才能知道</li>
<li>类中的实例方法是以链表形式存在,运行时候,可以修改链表中的实例方法,即可以增删改查,这与C中的函数默认都是extern的不同</li>
</ul>
</blockquote>

<h5>Runtime.h中OC类和对象的声明</h5>

<pre><code>//runtime.h
struct objc_object {
    Class isa  OBJC_ISA_AVAILABILITY;
    //struct objc_class *isa;
    //varFromGrandFather
    //varFromFather
    //VarFromSon
};
/*
这是由编译器为每个类产生的数据结构,这个结构定义了一个类.这个结构是通过编译器在执行时产生,在运行时发    送消息时使用.因此,一些成员改变了类型.编译器产生"char* const"类型的字符串指针替代了下面的成员变量    "super_class"
*/
struct objc_class {
    Class isa  OBJC_ISA_AVAILABILITY;
    //struct objc_class *isa;
};
</code></pre>

<p>在objc.h里，声明了两个类型：<code>Class</code>和<code>id</code>,分别代表<code>类</code>和<code>实例对象</code>,可以看作是泛型。
在Runtime.h里，我们看到OC类和对象其实就是两个结构体，其中第一个变量就是一个指向自己所属类的<code>isa</code>指针</p>

<blockquote><p>在OC中，一个对象的类由它的isa指针决定，isa指针指向这个对象所属的Class.或者可以这么说:<em>凡是地址是isa指针的结构体，都可以看做OC类</em></p></blockquote>

<h3>Objective-C类和对象的定义</h3>

<h4>objc-private.h 这里定义了OC对象</h4>

<pre><code>//objc-private.h
struct objc_object {
private:
    uintptr_t isa; //isa 指针，如果不是TaggedPointer，指向 Class

public:

    // ISA() assumes this is NOT a tagged pointer object
    Class ISA()
    {
        assert(!isTaggedPointer());
        return (Class)isa;
    }

    // getIsa() allows this to be a tagged pointer object
    Class getIsa()
    {
#if SUPPORT_TAGGED_POINTERS
        if (isTaggedPointer()) {
            uintptr_t slot =
                ((uintptr_t)this &gt;&gt; TAG_SLOT_SHIFT) &amp; TAG_SLOT_MASK;
            return objc_tag_classes[slot];
        }
#endif
        return ISA();
    }

    // changeIsa() should be used to change the isa of existing objects.
    // If this is a new object, use initIsa() for performance.
    Class changeIsa(Class cls);

    // initIsa() should be used to init the isa of new objects only.
    // If this object already has an isa, use changeIsa() for correctness.
    void initIsa(Class cls)
    {
        assert(!isTaggedPointer());
        isa = (uintptr_t)cls;
    }

    bool isTaggedPointer()
    {
#if SUPPORT_TAGGED_POINTERS
        return ((uintptr_t)this &amp; TAG_MASK);
#else
        return false;
#endif
    }
};
</code></pre>

<h4>objc-runtime-new.h 这里定义了OC类</h4>

<pre><code>//objc-runtime-new.h
struct objc_class : objc_object {
    // Class ISA;
    Class superclass;
    cache_t cache;
    uintptr_t data_NEVER_USE;
    /*....省略若干方法...*/
};
</code></pre>

<blockquote><p>一般程序语言，对象的尽头都是自己生了自己，自己下个蛋，爬出来了自己。似乎是个悖论，但确实如此。作为根类的NSObject就是这样一个家伙</p></blockquote>

<p><img src="/images/posts/struct.png" alt="Alt text" /></p>

<ul>
<li>super_class 指向父类的指针.因为Objective-C借鉴了SimTALK,在类的继承实现上,是通过一条继承链实现的.super_class就是整个继承链的核心字段.</li>
<li>name 类的名字</li>
<li>version 版本</li>
<li>info 信息</li>
<li>instance_size 实例的内存大小</li>
<li>ivars  是一个指向实例变量列表的指针</li>
<li>methodLists       是一个指向实例方法列表的指针</li>
<li>cache 缓存了常用的实例方法</li>
<li>protools 是一个指向协议列表的指针</li>
</ul>


<blockquote><p>我们知道,在Objective-C中,我们一般的定义形式是声明一个类的实例变量,属性,实例方法和类方法.并不能声明类变量.所以一般而言类对象的数据形式就是如上图的那些固定的字段.方法、属性和协议都存储在类定义的可写字段中，这些信息可以在运行时被改变。ivar存储在只读段，所以不能修改</p></blockquote>

<h2>OC对象模型分析</h2>

<ul>
<li>从OC类的定义中可以看出，OC的类继承自OC对象，每个类也有一个<code>isa</code>指针，每个类也能接收消息。例如:<code>[NSObject alloc]</code>,就是在向NSObject这个类发送名为<code>alloc</code>的消息，所以每个类也可以看做是一个对象。那么类也必须是另一个类的实例，这个类就是元类(<code>metaclass</code>).</li>
<li>就像类保存了实例对象的方法列表一样，元类也保存了类的方法列表缓存<code>cache_t cache</code>，方法cache是为了提高访问效率而设定的，用来缓存调用过的方法，这样下次再调用的时候就能提高查找效率。</li>
<li>元类(<code>metaclass</code>)也是一个对象，那么原来的对象指向哪里呢？为了设计上的完整，所有的元类的isa指针都指向一个根元类(<code>root metaclass</code>).根元类（root metaclass）本身的isa指向自己，这样就形成了一个闭环。在实际编程中，我们几乎不会遇到向元类发消息的情况，那它的isa指针在实际上很少用到。不过这么设计保证了面向对象的干净，即所有事物都是对象，都有isa指针。</li>
<li><p>我们再来看看继承关系，由于类方法的定义是保存在元类(metaclass)中，而方法调用的规则是，如果该类没有一个方法的实现，则向它的父类继续查找。所以，为了保证父类的类方法可以在子类中可以被调用，所以子类的元类会继承父类的元类，换而言之，类对象和元类对象有着同样的继承关系。</p></li>
<li><p><img src="/images/posts/class.png" alt="Alt text" /></p></li>
</ul>


<p>根据上图，我们可以看到以下几点：
- Root Class是指NSObject
- NSObject类包括它的对象实例方法
- NSObject的元类(q其实也就是根元类，这比较特殊)包括它的类方法，例如alloc方法
- NSObject的元类继承自NSObject类
- 创建一个OC类其实是创建一个类对（ClassPair）－类和元类，类的isa指针指向元类，元类的isa指向根元类，即图中的NSObject元类，根元类的isa指向它自己，形成闭环，保证isa指针永远不会为空 —同时这也会使得一个类（Class）可以 响应NSObject的所有实例方法
- isa指针指向就是消息传递的方向，通过isa指针没找到的消息，则继续通过superClass指针查找
- 对象中含有<code>实例变量</code>，类中含有<code>实例方法列表</code>，元类中含有<code>类方法列表</code>；NSobject的元类的superClass指向NSobject实例，所以理论上给元类发消息，能找到NSObject的实例方法，但我们在实际中很少用到</p>

<h3>为什么要有元类</h3>

<ol>
<li>可以分离类方法和实例方法</li>
<li>元类总是会保证Class对象会从基类继承所有的实例和类方法</li>
</ol>


<h3>成员变量的不可变与方法的可变</h3>

<p>Q:<code>为什么对象不能添加成员变量？</code>
A:因为对象在内存中的排布可以看成一个结构体，该结构体的大小不能动态变化，所以无法在运行时动态给对象增加成员变量</p>

<p>相对的，对象的方法定义都保存在类的可变区域中。Objective-C 2.0并未在头文件中将实现暴露出来，但在Objective-C 1.0中，我们可以看到方法的定义列表是一个名为<code>methodLists</code>的指针的指针（详见类的结构图)。通过修改该指针指向的指针的值，就可以实现动态地为某一个类增加成员方法。这也是Category实现的原理。同时也说明了为什么<code>Category</code>只可为对象增加成员方法，却不能增加成员变量。</p>

<p>需要特别说明一下，通过objc_setAssociatedObject 和 objc_getAssociatedObject方法可以变相地给对象增加成员变量，但由于实现机制不一样，所以并不是真正改变了对象的内存结构。</p>

<h3>isa-swizzling 在运行时动态创建一个类</h3>

<p><strong>修改类的isa被称为isa-swizzling技术。isa-swizzling就是类型混合指针机制。KVO主要通过isa-swizzling，来实现其内部查找定位的。</strong></p>

<blockquote><p>KVO（key－value observer）就是通过isa swizzling来实现的。 当我们为一个类的某个属性添加observer时候，框架自动创建这个类的一个子类，并且修改这个类的isa指向这个新的子类。 由于在ios中函数调用都是转化为isa查表形式，所以这次查得时新的子类的表， 也就是说对类的函数调用被子类给拦截了，在拦截的实现中就可以通知observer了。</p></blockquote>

<p>动态创建一个类需要三个步骤</p>

<blockquote><ol>
<li>为“class pair”－类和元类 创建存储空间（使用 objc_allocateClassPair).</li>
<li>为这个类添加所需的 methods 和 ivars（使用 class_addMethod).</li>
<li>注册这个类，然后就可以使用了（使用 objc_registerClassPair).</li>
</ol>
</blockquote>

<p>下面的代码在运行时创建了一个 NSError 的子类同时为它添加了一个方法：</p>

<pre><code>Class newClass =
    objc_allocateClassPair([NSError class], "RuntimeErrorSubclass", 0);
class_addMethod(newClass, @selector(report), (IMP)ReportFunction, "v@:");
objc_registerClassPair(newClass);
</code></pre>

<p>添加的方法使用叫ReportFunction 的函数作为实现，定义如下：</p>

<pre><code>void ReportFunction(id self, SEL _cmd)
{
    NSLog(@"This object is %p.", self);
    NSLog(@"Class is %@, and super is %@.", [self class], [self superclass]);

    Class currentClass = [self class];
    for (int i = 1; i &lt; 5; i++)
    {
        NSLog(@"Following the isa pointer %d times gives %p", i, currentClass);
        currentClass = object_getClass(currentClass);
    }

    NSLog(@"NSObject's class is %p", [NSObject class]);
    NSLog(@"NSObject's meta class is %p", object_getClass([NSObject class]));
}
</code></pre>

<h3>Method Swizzling (方法调配)</h3>

<p>Objective-C提供了以下API来动态替换类方法或实例方法的实现：
- <code>class_replaceMethod</code> 替换类方法的定义
- <code>method_exchangeImplementations</code> 交换2个方法的实现
- <code>method_setImplementation</code> 设置1个方法的实现</p>

<p>上面三个方法的差别:</p>

<ul>
<li><code>class_replaceMethod</code> ,有两种不同的行为。当类中没有想替换的原方法时，该方法会调用<code>class_addMethod</code>来为该类增加一个方法，也因为如此，<code>class_replaceMethod</code>在调用时需要传入types参数，而<code>method_exchangeImplementations</code>和<code>method_setImplementation</code>却不需要。</li>
<li>method_exchangeImplementations 的内部实现相当于调用了2次method_setImplementation方法。</li>
</ul>


<p>总结一下3个API的使用场景:
- <code>class_replaceMethod</code>, 当需要替换的方法可能有不存在的情况时，可以考虑使用该方法。
- <code>method_exchangeImplementations</code>，当需要交换2个方法的实现时使用。
- <code>method_setImplementation</code> 最简单的用法，当仅仅需要为一个方法设置其实现方式时使用。
- <code>ckass_getInstanceMethod</code> 根据给定的选择从类中抽取与之相关的方法</p>

<h3>用Method-Swizzling 调试“黑盒方法”</h3>

<p>selector名称对应的方法可以在运行期改变。类的方法列表会把选择子的名称映射到相关的方法实现上，使得“动态消息派发系统”能根据此找到应该调用的方法。这些方法均以函数指针的形式来表示，这种指针叫做IMP,原型如下：<code>id(*IMP)(id,SEL,……)</code></p>

<h5>实现两个方法的交换</h5>

<pre><code>Method originalMethod = class_getInstanceMethond([NSString class],@selector(lowercasestring));
Method swappedMethod = class_getInstanceMethod([NSString class],@selector(uppercaseString));
method_exchangeImplementations(originalMethod,swappedMethod);
</code></pre>

<p>然后在实际应用中，像这样直接交换两个方法实现的意义并不大。但是可以通过这一手段来为既有的方法实现新增功能.比如在调用lowercaseString时记录某些信息。</p>

<pre><code>@interface NSString (EOCMyAdditions)
- (NSString *)eoc_myLoercaseString;
@end

@implementation NSString (EOCMyAdditions)

- (NSString *)eoc_myLoercaseString{
NSString *lowercase = [self eoc_myLoercaseString];
NSLog(@"%@ = &gt; %@",self,lowercase);

return lowercase;
}

@end
</code></pre>

<p>使用时情况如下:</p>

<pre><code>Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));
Method swappedMethod  = class_getInstanceMethod([NSString class], @selector(eoc_myLoercaseString));
method_exchangeImplementations(originalMethod, swappedMethod);
NSString *testStr = @"Hello World";
NSString *lowercaseString = [testStr lowercaseString];
NSLog(@"%@",lowercaseString);
</code></pre>

		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner"><p>
  Copyright &copy; 2015 - Connor -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
			<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'igingko';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>






		</div>
	</div>
</body>
</html>
