---
layout: post
title: "Block详解"
date: 2014-12-16 15:10:58 +0800
comments: true
categories: 
---


## Block 是什么

> - 闭包是一个函数指针，再加上该函数执行的外部的上下文变量，而Block实际上就是Objective-C语言对闭包的实现
- Block是封装了代码逻辑(代码块)的OC对象
- 一个Block就是一个匿名的内联代码集合体
- 在某种意义上,也可以把Block理解成为OC的匿名函数
- 块是以扩展的形式加入到GCC编译器的，在近期版本的CLang中也可以使用

总而言之，**Block是实现闭包功能并封装了代码逻辑的OC对象**




## 怎样使用Block

### 声明

![Block Structure](/images/posts/blocks.png)

基本语法如下

	returnvalue (^BlockName)(parameters)

每个块都具备“固有类型”，所以也可以通过**typedef**来定义类型

	typedef int (^EOCScomeBlock)(BOOL flag,int value)
	
### 实现

	int (^AddBlock)(int,int) = ^(int a, int b){
		return a + b;
	}
	


## Block的内部结构

![Block Structure](/images/posts/block-struct.jpg)

如图所示，BLock一共分为6个部分:

1. 块本身是对象，在存放块对象的内存区域中，首个变量是指向Class对象的指针，该指针叫做isa
2. flags,用于按Bit位表示一些block的附加信息，
3. reverted 保留变量
4. invoke，这是内存布局中最重要的变量，这是个函数指针，指向块的实现代码(函数调用地址)。函数原型至少要接受一个void*型的参数，此参数代表块
5. descriptor标示该Block的附加描述信息，主要是Size大小，以及copy和dispose辅助函数的指针。辅助函数在Copy以及dispose的时候要指向一些其它操作，比如说，前者要保留捕获的对象，而后者则将之释放
6. variables, capture过来的变量，block能够访问它外部的局部变量，就是因为将这些变量复制到了结构体中。但需要注意的时拷贝的病不是对象本身，而是指向这些对象的指针变量。

## 全局快、栈块和堆块
在MRC下，定义块的时候所占的内存都是分配在栈中的,也就是说，块只在定义它的那个范围内有效。如下代码就有危险:

	void (^block)();
	if (){
		block = ^{};
	}else {
		block = ^{};
	}
	block();
	
在上面的代码中，if 和else中的代码都是分配在栈中的，等离开了相应的范围之后，编译器就有可能把分配给Block的内存覆盖掉，于是这两个Block只能保证在对应的范围内有效。

为了解决上面的问题，可以给块对象发送**Copy**消息，这样的话就会把块对象从栈中拷贝到堆中，块就成了带引用计数的对象了。修改之后的代码如下:

	void (^block)();
	if (){
		block =[^{} copy];
	}else {
		block = [^{} copy];
	}
	block();
	
上面说的时栈块和堆块，除此之外还有一种块叫做全局块，这种块不会捕捉任何状态(比如外围的变量等)，运行时也无须有状态来参与。块使用整个内存区域，在编译器已经完全确定了，因此，全局块可以声明在全局内存汇总，而不需要每次用到的时候在栈中创建。另外，对全局块的拷贝操作是个空操作，因为全局块不能被系统所回收。这种块实际上相当于单例。

**在ARC下，无论哪种块都是被分配在堆中的**
	


## Block的闭包性
在block内部，可以像普通函数一样访问数据：局部变量、传递给block的参数，全局变量/函数。并且由于block具有**闭包性**，所以还能访问非局部变量(non-local variable)。非局部变量定义在block之外，但是在block内部有它的作用域。例如，getFullCarName可以使用定义在block前面的make变量

	NSString *make = @"Honda";
	NSString *(^getFullCarName)(NSString *) = ^(NSString *model) {
    	return [make stringByAppendingFormat:@" %@", model];
	};
	NSLog(@"%@", getFullCarName(@"Accord"));    // Honda Accord
	
非局部变量会以const变量被拷贝并存储到block中，也就是说block对其是只读的。如果尝试在block内部给make变量赋值，会抛出编译器错误。

![Block Structure](/images/posts/const-non-local-variables.png)

以const拷贝的方式访问非局部变量，意味着block实际上并不是真正的访问了非局部变量——只不过在block中创建了非局部变量的一个快照。当定义block时，无论非局部变量的值是什么，都将被冻结，并且block会一直使用这个值，即使在之后的代码中修改了非局部变量的值。下面通过代码来看看，在创建好block之后，修改make变量的值，会发生什么

	NSString *make = @"Honda";
	NSString *(^getFullCarName)(NSString *) = ^(NSString *model) {
    	return [make stringByAppendingFormat:@" %@", model];
	};
	NSLog(@"%@", getFullCarName(@"Accord"));    // Honda Accord

	// Try changing the non-local variable (it won't change the block)
	make = @"Porsche";
	NSLog(@"%@", getFullCarName(@"911 Turbo")); // Honda 911 Turbo
	
block的闭包性为block与上下文交互的时候带来极大的便利性，当block需要额外的数据时，可以避免使用参数——只需要简单的使用非局部变量即可。

## 修改局部变量

冻结中的非局部变量是一个常量值，这也是一种默认的安全行为——因为这可以防止在block中的代码对非局部变量做了意外的修改。那么如果我们希望在block中对非局部变量值进行修改要如何做呢——用__block存储修饰符(storage modifier)来声明非局部变量：

	__block NSString *make = @"Honda";
	
这将告诉block对非局部变量做引用处理，在block外部make变量和内部的make变量创建一个直接的链接(direct link)。现在就可以在block外部修改make，然后反应到block内部，反过来，也是一样。

![Block Structure](/images/posts/mutable-non-local-variables.png)

## Block作用

- 作为回调，取代Delegate,可以让代码变得简单，以及减少函数声明的数量
- block能够在函数内部声明实现，并捕捉词法范围内的状态，并能在一定条件下修改这些状态
- 用Blcok作为回调，可以让代码逻辑变得紧凑，并切可以直接访问局部变量
- BLock可以使用在任务完成回调处理、消息监听回调处理、错误回调处理、枚举回调、视图动画变化、排序